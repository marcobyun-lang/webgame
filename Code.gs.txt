// Code.gs

function doGet(e) {
  let output;
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    // 랭킹 데이터 요청 (전체 및 직업별 통합)
    if (e.parameter.type === 'ranking' || e.parameter.type === 'allRankings') {
      const result = {
        overall: getRankingsFromSheet(ss, 'Ranking'),
        warrior: getRankingsFromSheet(ss, 'warrior'),
        rogue: getRankingsFromSheet(ss, 'rogue'),
        mage: getRankingsFromSheet(ss, 'mage'),
        archer: getRankingsFromSheet(ss, 'archer')
      };
      output = ContentService.createTextOutput(JSON.stringify(result));
    } else {
        // 일반 캐릭터 데이터 불러오기
        let sheet = ss.getSheetByName('시트1') || ss.getSheets()[0];
        const name = e.parameter.name;
        const data = sheet.getDataRange().getValues();

        let found = false;
        for (let i = 1; i < data.length; i++) {
            if (data[i][0] == name) {
                output = ContentService.createTextOutput(data[i][1]);
                found = true;
                break;
            }
        }

        if (!found) {
            output = ContentService.createTextOutput(JSON.stringify({ error: "Not Found" }));
        }
    }
  } catch (err) {
    output = ContentService.createTextOutput(JSON.stringify({ error: err.toString() }));
  }

  return output.setMimeType(ContentService.MimeType.JSON).setHeader('Access-Control-Allow-Origin', '*');
}

// 시트에서 랭킹 데이터를 읽어오는 헬퍼 함수
function getRankingsFromSheet(ss, sheetName) {
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet || sheet.getLastRow() <= 1) return [];

  const data = sheet.getDataRange().getValues();
  let rankings = [];

  // 상위 10개 데이터 가져오기 (헤더 제외)
  const numRows = Math.min(data.length, 11);
  for (let i = 1; i < numRows; i++) {
    if (data[i][0]) {
      rankings.push({
        name: data[i][0],
        score: Number(data[i][1] || 0),
        job: data[i][2],
        level: Number(data[i][3] || 1),
        bossKills: Number(data[i][5] || 0)
      });
    }
  }
  return rankings;
}

// 1. 데이터 저장 (POST 요청)
function doPost(e) {
  let output;
  const lock = LockService.getScriptLock();
  // 30초 락 시도 (동시성 제어) - 실패 시 에러 반환
  if (!lock.tryLock(30000)) {
    output = ContentService.createTextOutput(JSON.stringify({result: "error", error: "Server Busy"}));
    return output.setMimeType(ContentService.MimeType.JSON).setHeader('Access-Control-Allow-Origin', '*');
  }

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const contents = e.postData.contents;

    if (!contents) {
      output = ContentService.createTextOutput(JSON.stringify({result: "error", error: "No content"}));
      return output.setMimeType(ContentService.MimeType.JSON).setHeader('Access-Control-Allow-Origin', '*');
    }

    const params = JSON.parse(contents);

    // 랭킹 저장 요청인지 확인
    if (params.type === 'ranking') {
      return saveRanking(ss, params);
    }

    // 일반 캐릭터 데이터 저장
    let sheet = ss.getSheetByName('시트1') || ss.getSheets()[0];
    const name = params.name;
    const jsonData = JSON.stringify(params);

    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == name) {
        rowIndex = i + 1;
        break;
      }
    }

    if (rowIndex > 0) {
      sheet.getRange(rowIndex, 2).setValue(jsonData);
      sheet.getRange(rowIndex, 3).setValue(new Date());
    } else {
      sheet.appendRow([name, jsonData, new Date()]);
    }

    output = ContentService.createTextOutput(JSON.stringify({result: "success"}));

  } catch (err) {
    output = ContentService.createTextOutput(JSON.stringify({result: "error", error: err.toString()}));
  } finally {
    lock.releaseLock();
  }
  return output.setMimeType(ContentService.MimeType.JSON).setHeader('Access-Control-Allow-Origin', '*');
}

// 랭킹 저장 함수
function saveRanking(ss, params) {
  try {
    // 1. 전체 랭킹 저장
    updateSheetRanking(ss, 'Ranking', params);

    // 2. 직업별 랭킹 저장
    const jobSheetMap = {
      '전사': 'warrior',
      '도적': 'rogue',
      '마법사': 'mage',
      '엘프 궁수': 'archer'
    };
    const targetSheetName = jobSheetMap[params.job];
    if (targetSheetName) {
      updateSheetRanking(ss, targetSheetName, params);
    }

    return ContentService.createTextOutput(JSON.stringify({result: "success", message: "Ranking Updated"}))
        .setMimeType(ContentService.MimeType.JSON)
        .setHeader('Access-Control-Allow-Origin', '*');
  } catch (e) {
    return ContentService.createTextOutput(JSON.stringify({result: "error", error: e.toString()}))
        .setMimeType(ContentService.MimeType.JSON)
        .setHeader('Access-Control-Allow-Origin', '*');
  }
}

// 특정 시트의 랭킹을 업데이트하는 함수
function updateSheetRanking(ss, sheetName, params) {
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    sheet.appendRow(['Name', 'Score', 'Job', 'Level', 'UpdatedAt', 'BossKills']);
  }

  if (sheet.getLastRow() === 0) {
    sheet.appendRow(['Name', 'Score', 'Job', 'Level', 'UpdatedAt', 'BossKills']);
  }

  const data = sheet.getDataRange().getValues();
  let rowIndex = -1;
  const playerName = params.name || "Unknown";

  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == playerName) {
      rowIndex = i + 1;
      break;
    }
  }

  const newScore = Number(params.score || 0);

  if (rowIndex > 0) {
    const oldScore = Number(data[rowIndex - 1][1] || 0);
    if (newScore > oldScore) {
      sheet.getRange(rowIndex, 1, 1, 6).setValues([[
        playerName,
        newScore,
        params.job || "Novice",
        Number(params.level || 1),
        new Date(),
        Number(params.bossKills || 0)
      ]]);
    }
  } else {
    sheet.appendRow([
      playerName,
      newScore,
      params.job || "Novice",
      Number(params.level || 1),
      new Date(),
      Number(params.bossKills || 0)
    ]);
  }

  const lastRow = sheet.getLastRow();
  if (lastRow > 1) {
    const lastCol = sheet.getLastColumn();
    const range = sheet.getRange(2, 1, lastRow - 1, lastCol);
    range.sort({column: 2, ascending: false});
  }

  if (sheet.getLastRow() > 11) {
    sheet.deleteRows(12, sheet.getLastRow() - 11);
  }
}