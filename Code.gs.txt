// Code.gs

// 1. 데이터 저장 (POST 요청)
function doPost(e) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const contents = e.postData.contents;
    const params = JSON.parse(contents);

    // 랭킹 저장 요청인지 확인
    if (params.type === 'ranking') {
      return saveRanking(ss, params);
    }

    // 일반 캐릭터 데이터 저장 (수동 저장 시에만 호출됨)
    let sheet = ss.getSheetByName('시트1') || ss.getSheets()[0];
    const name = params.name;
    const jsonData = JSON.stringify(params);

    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == name) {
        rowIndex = i + 1;
        break;
      }
    }

    if (rowIndex > 0) {
      sheet.getRange(rowIndex, 2).setValue(jsonData);
      sheet.getRange(rowIndex, 3).setValue(new Date());
      return ContentService.createTextOutput("Updated").setMimeType(ContentService.MimeType.TEXT);
    } else {
      sheet.appendRow([name, jsonData, new Date()]);
      return ContentService.createTextOutput("Created").setMimeType(ContentService.MimeType.TEXT);
    }
  } catch (err) {
    return ContentService.createTextOutput("Error: " + err.toString()).setMimeType(ContentService.MimeType.TEXT);
  }
}

// 랭킹 저장 함수
function saveRanking(ss, params) {
  let rankSheet = ss.getSheetByName('Ranking');
  if (!rankSheet) {
    rankSheet = ss.insertSheet('Ranking');
    rankSheet.appendRow(['Name', 'Score', 'Job', 'Level', 'UpdatedAt']);
  }

  const newScore = parseInt(params.score);
  const data = rankSheet.getDataRange().getValues();
  let rankings = [];

  // 기존 데이터 파싱 (헤더 제외)
  for (let i = 1; i < data.length; i++) {
    if (data[i][0]) { // 이름이 있는 행만 처리
      rankings.push({
        name: data[i][0],
        score: parseInt(data[i][1]),
        job: data[i][2],
        level: data[i][3],
        date: data[i][4]
      });
    }
  }

  // 새 점수 추가
  rankings.push({
    name: params.name,
    score: newScore,
    job: params.job,
    level: params.level,
    date: new Date()
  });

  // 점수 내림차순 정렬
  rankings.sort((a, b) => b.score - a.score);

  // 상위 10개만 유지
  rankings = rankings.slice(0, 10);

  // 시트 초기화 및 다시 쓰기
  rankSheet.clear(); // 서식까지 모두 삭제
  rankSheet.appendRow(['Name', 'Score', 'Job', 'Level', 'UpdatedAt']);
  rankings.forEach(r => {
    rankSheet.appendRow([r.name, r.score, r.job, r.level, r.date]);
  });

  return ContentService.createTextOutput("Ranking Updated").setMimeType(ContentService.MimeType.TEXT);
}

// 2. 데이터 불러오기 (GET 요청)
function doGet(e) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    // 랭킹 데이터 요청
    if (e.parameter.type === 'ranking') {
      let rankSheet = ss.getSheetByName('Ranking');
      if (!rankSheet) return ContentService.createTextOutput(JSON.stringify([])).setMimeType(ContentService.MimeType.JSON);

      const data = rankSheet.getDataRange().getValues();
      let rankings = [];
      for (let i = 1; i < data.length; i++) {
        if (data[i][0]) {
          rankings.push({
            name: data[i][0],
            score: data[i][1],
            job: data[i][2],
            level: data[i][3]
          });
        }
      }
      return ContentService.createTextOutput(JSON.stringify(rankings)).setMimeType(ContentService.MimeType.JSON);
    }

    // 일반 캐릭터 데이터 불러오기
    let sheet = ss.getSheetByName('시트1') || ss.getSheets()[0];
    const name = e.parameter.name;
    const data = sheet.getDataRange().getValues();

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == name) {
        return ContentService.createTextOutput(data[i][1]).setMimeType(ContentService.MimeType.JSON);
      }
    }

    return ContentService.createTextOutput(JSON.stringify({ error: "Not Found" })).setMimeType(ContentService.MimeType.JSON);
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ error: err.toString() })).setMimeType(ContentService.MimeType.JSON);
  }
}