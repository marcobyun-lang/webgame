// Code.gs

// 1. 데이터 저장 (POST 요청)
function doPost(e) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const contents = e.postData.contents;
    const params = JSON.parse(contents);

    // 랭킹 저장 요청인지 확인
    if (params.type === 'ranking') {
      return saveRanking(ss, params);
    }

    // 일반 캐릭터 데이터 저장 (수동 저장 시에만 호출됨)
    let sheet = ss.getSheetByName('시트1') || ss.getSheets()[0];
    const name = params.name;
    const jsonData = JSON.stringify(params);

    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == name) {
        rowIndex = i + 1;
        break;
      }
    }

    if (rowIndex > 0) {
      sheet.getRange(rowIndex, 2).setValue(jsonData);
      sheet.getRange(rowIndex, 3).setValue(new Date());
      return ContentService.createTextOutput("Updated").setMimeType(ContentService.MimeType.TEXT);
    } else {
      sheet.appendRow([name, jsonData, new Date()]);
      return ContentService.createTextOutput("Created").setMimeType(ContentService.MimeType.TEXT);
    }
  } catch (err) {
    return ContentService.createTextOutput("Error: " + err.toString()).setMimeType(ContentService.MimeType.TEXT);
  }
}

// 랭킹 저장 함수 (수정됨)
function saveRanking(ss, params) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // 30초 동안 잠금 대기

  try {
    let rankSheet = ss.getSheetByName('Ranking');
    if (!rankSheet) {
      rankSheet = ss.insertSheet('Ranking');
      rankSheet.appendRow(['Name', 'Score', 'Job', 'Level', 'UpdatedAt']);
    }

    // 새 점수 추가
    rankSheet.appendRow([params.name, params.score, params.job, params.level, new Date()]);

    // 데이터가 2줄 이상일 때 (헤더 + 데이터 1개 이상) 정렬 수행
    if (rankSheet.getLastRow() > 1) {
      const range = rankSheet.getRange(2, 1, rankSheet.getLastRow() - 1, rankSheet.getLastColumn());
      range.sort({column: 2, ascending: false}); // 점수(2번째 열)를 기준으로 내림차순 정렬
    }

    // 상위 10개 랭킹만 남기고 삭제
    if (rankSheet.getLastRow() > 11) { // 헤더(1) + 랭킹(10) = 11
      rankSheet.deleteRows(12, rankSheet.getLastRow() - 11);
    }

    return ContentService.createTextOutput("Ranking Updated").setMimeType(ContentService.MimeType.TEXT);
  } catch (e) {
    return ContentService.createTextOutput("Error: " + e.toString()).setMimeType(ContentService.MimeType.TEXT);
  } finally {
    lock.releaseLock();
  }
}


// 2. 데이터 불러오기 (GET 요청)
function doGet(e) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    // 랭킹 데이터 요청
    if (e.parameter.type === 'ranking') {
      let rankSheet = ss.getSheetByName('Ranking');
      if (!rankSheet) return ContentService.createTextOutput(JSON.stringify([])).setMimeType(ContentService.MimeType.JSON);

      const data = rankSheet.getDataRange().getValues();
      let rankings = [];
      // 상위 10개 또는 그 이하의 데이터만 가져오기
      const numRows = Math.min(data.length, 11); // 헤더 포함 최대 11줄
      for (let i = 1; i < numRows; i++) {
        if (data[i][0]) {
          rankings.push({
            name: data[i][0],
            score: data[i][1],
            job: data[i][2],
            level: data[i][3]
          });
        }
      }
      return ContentService.createTextOutput(JSON.stringify(rankings)).setMimeType(ContentService.MimeType.JSON);
    }

    // 일반 캐릭터 데이터 불러오기
    let sheet = ss.getSheetByName('시트1') || ss.getSheets()[0];
    const name = e.parameter.name;
    const data = sheet.getDataRange().getValues();

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == name) {
        return ContentService.createTextOutput(data[i][1]).setMimeType(ContentService.MimeType.JSON);
      }
    }

    return ContentService.createTextOutput(JSON.stringify({ error: "Not Found" })).setMimeType(ContentService.MimeType.JSON);
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ error: err.toString() })).setMimeType(ContentService.MimeType.JSON);
  }
}
